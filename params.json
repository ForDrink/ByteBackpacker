{"name":"Bytebackpacker","tagline":"ByteBackpacker is a small utility written in Swift to pack value types into a Byte array and unpack them back. ","body":"<img src=\"https://github.com/michaeldorner/ByteBackpacker/blob/master/icon.png\" width=\"200\" align=\"right\">\r\n[![Build Status](https://travis-ci.org/michaeldorner/ByteBackpacker.svg)](https://travis-ci.org/michaeldorner/ByteBackpacker) [![codecov.io](https://codecov.io/github/michaeldorner/ByteBackpacker/coverage.svg?branch=master)](https://codecov.io/github/michaeldorner/ByteBackpacker?branch=master)\r\n\r\n# ByteBackpacker\r\n\r\nByteBackpacker is a small utility written in Swift to pack value types into a `Byte` array and unpack them back. Additionally, there is a [`NSData`](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/) [extension](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html) to convert `NSData` objects into a `Byte` array. \r\n\r\n`Byte` is a [`typealias`](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID361) for `UInt8`.\r\n\r\n\r\n## Embedding in projects\r\n\r\n1. Copy the [`ByteBackpacker.swift`](https://github.com/michaeldorner/ByteBackpacker/blob/master/ByteBackpacker/ByteBackpacker.swift) file (containing the `ByteBackpacker` class) to your project.\r\n2. No second step, you are done. \r\n\r\nAlthough it can be used in the same way in Objective-C, I had clearly Swift projects in mind. The easiest way for Objective-C users is to embed the `ByteBackpacker.framework`. Of course, Swift users can also do this, but actually I do not see any advantages.\r\n\r\n## Usage\r\nImportant for a proper usage: **ByteBackpacker does only support value types (e.g. numbers, structs, ...), but no reference types (e.g. classes)!** For further information see [Discussion](#discussion).\r\n\r\n### Examples\r\n\r\n#### From `Double` to `[Byte]` and from `[Byte]` to `Double`\r\n\r\n```\r\nlet aDouble: Double = 1.0\r\nlet byteArray: [Byte] = ByteBackpacker.pack(aDouble)\r\n\r\n// either without type inference\r\nlet doubleFromByteArray: Double = ByteBackpacker.unpack(byteArray)\r\nlet doubleFromByteArray = ByteBackpacker.unpack(byteArray) as Double\r\n\r\n// or with type inference, but explizit type parameter\r\nlet doubleFromByteArray = ByteBackpacker.unpack(byteArray, toType: Double.self)\r\n```\r\n\r\n#### From `Double` over `NSData` to `[Byte]` and from `[Byte]` to `Double`\r\n\r\n```\r\nvar aDouble: Double = 1.0\r\nlet data = NSData(bytes: &aDouble, length: sizeof(Double.self))\r\nlet byteArray = data.toByteArray()\r\nlet doubleFromByteArray = ByteBackpacker.unpack(byteArray, toType: Double.self)\r\n```\r\n\r\n### API\r\n\r\n`Byte` is a [`typealias`](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID361) for `UInt8`.\r\n\r\n`ByteOrder` is an `enum` for [Little Endian and Big Endian](https://en.wikipedia.org/wiki/Endianness). Furthermore, there is the option for asking the platform you are using for the native byte order of the system: `ByteOrder.nativeByteOrder`. By default `.nativeByteOrder` is applied for packing and unpacking. \r\n\r\nFor packing value types into a `[Byte]`, use\r\n\r\n```class func pack<T>(var value: T, byteOrder: ByteOrder = .nativeByteOrder) -> [Byte]```\r\n\r\nFor unpacking a `[Byte]` into a value type, use either\r\n\r\n```public class func unpack<T>(valueByteArray: [Byte], byteOrder: ByteOrder = .nativeByteOrder) -> T```\r\n\r\nor otherwise, if you want to use type inference\r\n\r\n```class func unpack<T>(valueByteArray: [Byte], toType type: T.Type, byteOrder: ByteOrder = .nativeByteOrder) -> T```\r\n\r\n\r\n## Discussion\r\n\r\nUnfortunately, there is no suitable option for specifying value types in Swift's generics (see [here the discussion on stackoverflow](http://stackoverflow.com/q/28782532/1864294)). It would be awesome to specify our methods like `func (un)pack<T: Any where T: ~AnyClass>(...)`, but until today Swift does not provide us this opportunities. We will see what the future brings us.\r\n\r\nI would love to improve this project. Tell me your ideas, here in github, via mail or in [codereview.stackexchange.com](http://codereview.stackexchange.com/questions/114730/type-to-byte-array-conversion-in-swift).\r\n\r\n\r\n## Contributions\r\n\r\n- [ ] Add more test cases \r\n- [ ] Add more examples and how-tos \r\n- [ ] Find a solution for making sure, that `T` is a value type, but not a reference type \r\n\r\n## Licence \r\n\r\nByteBackpacker is released under the MIT license. See [LICENSE](LICENSE) for details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}